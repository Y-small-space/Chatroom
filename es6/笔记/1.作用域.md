# 作用域

目标：了解作用域对程序执行的影响及作用域链的查找机制，使用闭包函数创建隔离作用城避免全局变量污染。

* 作用域（scope）规定了变量能够被访问的“范国”，离开了这个“范围〞 变量便不能被访问，
* 作用域分为：
  * 全局作用域
  * 局部作用域

## 局部作用域

局部作用域分为函数作用域和块作用域。

### 1.函数作用域

在函数内部声明的变量只能在函数内部被访问，外部无法直接访问。

    <script>
        function getSum() {
            // 函数内部是函数作用域 属于局部变量
            const num = 10
        }
        console.log(num) //此处报错 函数外部不能使用局部作用域变量
    </script>

总结：

1. 函数内部声明的变量，在函数外部无法被访问
2. 函数的参数也是函数内部的局部变量
3. 不同函数内部声明的变量无法互相访问
4. 函数执行完毕后，函数内部的变量实际被清空了

### 2. 块作用域

在 Javascript 中使用{}包裹的代码称为代码块，代码块内部声明的变量外部将 [**有可能**] 无法被访问。

    for (let t=1;t<=6;t++){
    // t只能在该代码块中被访问
    console.log(t)// 正常
    }
    // 超出了t的作用域
    console.log(t)//报错

1. let 声明的变量会产生块作用域，var 不会产生块作用域
2. const 声明的常量也会产生块作用域
3. 不同代码块之问的变量无法互相访问
4. 推荐使用 let 或 const

## 全局作用域

\<script>标签和 .js文件 的 [最外层] 就是所谓的全局作用域，在此声明的变量在函数内部也可以被访问。
全局作用域中声明的变量，任何其它作用域都可以被访问

    <script>
        // 全局作用域
        // 全局作用域下声明了 num 変量
        const num = 10
        function fn() {
        // 函数内部可以使用全局作用域的变量
        console.log(num)
        }
        // 此处全局作用域
    </script>

注意：

1. 为window对象动态添加的属性默认也是全局的，不推荐！！！
2. 函数中未使用任何关键字声明的变量为全局变量，不推荐！！！
3. 尽可能少的声明全局变量，防止全局变量被污染

## 作用域链

作用域链本质上是底层的变量查找机制。

* 在函数被执行时，会优先查找当前函数作用域中查找变量
* 如果当前作用域查找不到则会依次逐级查找父级作用域直到全局作用域

        <script>
            //全局作用域
            let a = 1
            let b = 2
            //局部作用域
            function f() {
                let a = 1
                //局部作用域
                function g() {
                    a = 2
                    console.log(a)
                }
                g() // 调用
            }
            f() // 调用
        </script>

总结：

1. 嵌套关系的作用域串联起来形成了作用域链
2. 相同作用域链中按着从小到大的规则查找变量
3. 子作用域能够访问父作用域，父级作用域无法访问子级作用域

## 垃圾回收机制

垃圾回收机制(Garbage Collection)筒称 GC

JS中内存的分配和回收都是自动完成的，内存在不使用的时候会被垃圾回收器自动回收

### 内存的生命周期

JS环境中分配的内存，一般有如下生命周期：

1. 内存分配：当我们声明变量、函数、对象的时候，系统会自动为他们分配内存
2. 内存使用：即读写内存，也就是使用变量、函数等
3. 内存回收：使用完毕，由垃圾回收器自动回收不再使用的内存

        // 为交量分配内存
        const age = 18

        // 为对象分配内存
        const obj = {
            age: 19
        }

        // 为函数分配内存
        function fn() {
            const age = 18
            console.log(age)
        }

### 说明

* 全局变量一般不会回收(关闭页面回收)
* 一般情况下局部变量的值，不用了，会被自动回收掉

### 内存泄漏

程序中分配的内存由于某种原因程序末释放或无法释放叫做内存泄漏

**拓展-S垃圾回收机制-算法说明**:

堆栈空间分配区别:

1. 栈（操作系统）: 由操作系统自动分配释放函数的参数值、局部变量等，基本数据类型放到栈里面。
2. 堆（操作系统）: 一般由程序员分配释放，若程序员不释放，由垃圾回收机制回收。复杂数据类型放到堆里面。

下面介绍两种常见的浏览器垃圾回收算法：**引用计数法** 和 **标记清除法**

* 引用计数法

IE 采用的引用计数算法，定义"内存不再使用", 就是看一个对象是否有指向它的引用，没有引用了就回收对象

算法:

1. 跟踪记录被**引用的次数**
2. 如果被引用了一次，那么就记录次数1，多次引用会**累加++**
3. 如果减少一个引用就**减1 --**
4. 如果引用次数是**0**，则释放内存

但它却存在一个致命的问题：**嵌套引用**（循环引用）

如果两个对象相互引用，尽管他们已不再使用，垃圾回收器不会进行回收，导致内存泄露。

    function fn() {
        let o1 = {}
        let o2 = {}
        o1.a = o2
        o2.a = o1
        return '引用计数无法回收'
    }
    fn()

因为他们的引用次数永远不会是0。这样的相互引用如果说很大量的存在就会导致大量的内存泄露

* 标记清除法

现代的浏览器已经不再使用引用计数算法了。

现代浏览器通用的大多是基于标记清除算法的某些改进算法，总体思想都是一致的。

核心：

1. 标记清除算法将 "不再使用的对象" 定义为 "**无法达到的对象**"。
2. 就是从**根部**（在JS中就是全局对象）出发定时扫描内存中的对象。凡是能从**根部到达**的对象，都是还**需要使用**的。
3. 那些**无法**由根部出发触及到的**对象被标记**为不再使用，稍后进行**回收**。

## 闭包

目标：能说出什么是闭包，闭包的作用以及注意事项

概念：一个函数对周围状态的引用捆绑在一起，内层函数中访问到其外层函数的作用域

简单理解：**闭包 = 内层函数 ＋ 外层函数的变量**

先看个简单的代码：

    function outer () {
        const a = 1
        function f(){
            console.log(a)
        }
        f()
    }
    outer()

闭包作用：封闭数据，提供操作，外部也可以访问函数内部的变量

闭包的基本格式：

    function outer() {
        let i = 1
        function fn() {
            console.log(i)
        }
        return fn
    }
    const fun = outer()
    fun() // 1
    // 外层函数使用内部函数的变量

    简约写法
    function outer() {
        let i = 1
        return function() {
            console. log(i)
        }
    }
    const fun = outer()
    fun()// 调用fun
    // 外层函数使用内部函数的变量

闭包应用：实现数据的私有

比如，我们要做个统计函数调用次数。函数调用一次，就++

* 但是，这个count 是个全局变量，很容易被修改

        let count = 1
        function fn(){
            count++
            console.log(`函数被调用用${count}次`)
        }
        fn() // 2
        fn() // 3

* 这样实现了数据私有，无法直接修改count

        function count () {
            let i = 0

            function fn() {
                i++ 
                console. log(i)
            }

            return fn
        }
        const fun = count()
        fun()

## 变量提升

目标：了解什么是变量提升

变量提升是 JavaScript 中比较“奇怪〞 的现象，它允许在变量声明之前即被访问(仅存在于var声明变量)

注意：

1. 变量在未声明即被访问时会报语法错误
2. 变量在var声明之前即被访问，变量的值为 undefined
3. let/const 声明的変量不存在変量提升
4. 变量提升出现在相同作用域当中
5. 实际开发中推荐先声明再访问变量

        <script>
            // 访问变量 str
            console.log(str + 'world!')
            // 声明变量 str
            var str = 'hello ' 
        </script>

说明：

Js初学者经常花很多时间才能习惯变量提升，还经常出现一些意想不到的bug，正因为如此，ES6 引入了块级作用域，用 let 或者 const 声明变量，让代码写法更加规范和人性化。

